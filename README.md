# Banjo (Lanit AT framework-box) 
![license](https://img.shields.io/github/license/lanit-izh/automation-framework-box) ![version](https://img.shields.io/badge/version-4.0.9-green) ![snapshot](https://img.shields.io/badge/snapshot-4.0.10-blue)

## Общая информация
Образцовая реализация [Banjo Core](https://github.com/lanit-izh/automation-framework-core) с использованием TestNG, Cucumber и Yandex Allure. Подробная инструкция по установке и использованию содержится в [wiki проекта](https://github.com/lanit-izh/automation-framework-box/wiki)
Большая часть структуры обусловлена использованием фреймворка [Atlas](https://github.com/qameta/atlas), а так же нашим собственным опытом в имплементации подхода BDD и в частности фреймворка [Cucucmber](https://github.com/cucumber/cucumber)
### pages
В пакете `main/pages` раполагаются интерфейсы, являющиеся абстрактным представлением тестируемых web-страниц. В них описываются явно в виде методов с аннотацией @FindBy элементы страницы по принципу классического PageObject. Этот паттерн дополнен подходом из Atlas: типичные, часто используемые элементы с тривиальными локаторами, подключатся в виде наследования интерфейса, предоставляющего метод с уже прописанными относительными локаторами.
По соглашению название интерфейса страницы заканчивается на `Page`.
### html_elements 
В пакете `main/pages/html_elements` релизованы наиболее часто встречающиеся элементы интерфейса со стандартными локаторами. Каждый интерфейс элемента может содержать дефолтные методы по работе с этим элементом, характерные только для данного типа элемента.
Методы, предоставляющие доступ к элементу на странице по соглашению реализуются во вложенном интерфейсе `With[Element]`, например для кнопки Button вложенный интерфейс, предоставляющий методы для получения этого элемента, называется `WithButton`.
Реализованы следующие стандартные элементы интерфейса страниц:
* Button -- кнопка, кнопка с текстом
* CheckBox -- чекбокс 
* DatePicker -- поле с выбором даты
* DropDown -- выпадающий список
* Input -- поле ввода
* Link -- ссылка
* RadioButton -- кнопка-переключатель выбора из списка
* Text -- текстовое поле
* TextArea -- многострочное поле ввода
### domain
В зависимости от количества используемых в тестировании доменных имён, можно разделять их дополнительно. В некоторых случаях достаточно поделить страницы по пакетам. Характерные только для данной страницы элементы или блоки располагаются во вложенном пакете `blocks` и `elements`. Общие для нескольких страниц выносятся в вышележащие пакеты.
### blocks
Элементы на странице бывают конечными, такие как кнопка, поле ввода, но могут быть так же блочными, с вложенными элементами. В зависимости от этого они наследуются от  `UIElement` либо от `AbstractBlockElement`. При этом соглашение об использовании аналогично конечным элементам. Для предоставления стандартных методов получения блочного элемента, внутри объявляется вложенный интерфейс с префиксом With, который затем наследуется страницей или другим блочным элементом.
### steps
В пакете `main/java/steps` располагаются классы с определением шагов для Cucumber-сценариев. Для простоты ориентирования и уменьшения количества дублирующих шагов, они располагаются в подпакетах, соответствующих конечному элементу взаимодействия в шаге.
Базовые шаги реализованы в `CommonStepsLibrary`, их список и формулировки могут отличаться в каждой версии имплементации фреймворка.
### features
Сценарии располагаются в `test/resources/features`
### configs
Все основные настройки запуска расположены в пакете `main/resources/config`. 

## Использование
### Web-UI
1. Параметры для запуска тестов хранятся в файле  `default.properties`.
   Для запуска тестов с  параметрами из  другого файла  необходимо при запуске передать `-Dtest.properties="/custom.properties"`, где custom.properties - файл с необходимыми настройками .
  Также необходимые параметры можно переопределить, передав их в командной строке, например `-Dsite.url="https://google.ru"` 
2. Для каждой из тестируемых страниц создается отдельный интерфейс в пакете `main/java/pages`. Для удобства использования на родном языке, в аннотации `@Title` можно указать читаемое название страницы.
3. В страницах подключить подходящие стандартные элементы при помощи наследования *With*-интерфейсов, либо прописать свои методы согласно подходу [Atlas](https://github.com/qameta/atlas)
4. Создать feature-файл в пакете `test/resources/features` с произвольным названием. Первый шаг сценария обычно является открытием тестируемого приложения. Далее добавляются шаги действий и проверок.
5. Запуск Cucumber-тестов осуществляется с ключем -fn, пример: `mvn test -fn -Dcucumber.options="--tags @SampleScenarioFail"`, т.к. для корректной работы CI необходимо выключить параметр <testFailureIgnore> в maven-surefire-plugin.

### Выполнение интеграционных тестов (end-to-end) 
Для end-to-end тестирования, можно воспользоваться функционалом дата провайдера, который позволяет сохранять и получать  данные из разных тестируемых систем из общего хранилища. 
 Для работы с дата провайдером в качестве сервиса для обмена данными между тестовыми запусками используется 
 [Postgrest](http://postgrest.org/en/v7.0.0/)
 , устанавливается отдельно. 
   
   Параметры используемой таблицы и адрес ДП можно задать в файле default.properties, либо в командной строке 
   `-Ddp.url="http://ipaddress:port"` и (или) `-Ddp.table="table_name"`.
   
   Sql скрипт дл содоздания таблицы:
    
    CREATE TABLE public.aliases (
      pipeline_id int4 NULL,
      run_uid varchar NULL,
      step_id int4 NULL,
      alias_name varchar NOT NULL,
      value jsonb NULL,
      CONSTRAINT aliases_pk PRIMARY KEY (alias_name)
    );
 
 В каталоге dp_files лежит compose файл для запуска Датапровайдера в докере. 
    
    Команда запуска : docker-compose up -d
     
 
  
#### Использование в тестах
1. Для end-to-end тестирования необходимо указать адрес сервиса дата-провайдера в профиле, `default.properties` или в командной строке `-Ddp="http://ipaddress:port"`. 
2. Для сохранения тестовых данных при запуске теста необходимо передать параметр `-Dalias_output=tableName`, где  tableName , название таблицы в которую будут сохранены данные из теста.  В таблицу будут сохранены те тестовые данные, которые в процессе порхождения теста были сохранены в хранилище данных (DataKeeper), обьект которого можно получить используя строку: `Context.getInstance().getBean("dataKeeper")` 

3. Для использование ранних тестовых данных при запуске теста необходимо передать параметр `-Dalias_input=tableName`, 
где  tableName , название таблицы из которой необходимо взять данные из теста. В результате перед выполнением тестовых шагов, 
все данные из таблицы будут сохранены в  хранилище данных (DataKeeper), объект которого можно получить используя строку: `Context.getInstance().getBean("dataKeeper")`

4. Для подстановки сохраненных данных в тестовые шаги  необходимо: 
 4.1) В feature файле в качестве передаваемого значения использовать строку вида:
  `ДатаПровайдер!(DPvalue,defaultValue)`
  где, DPvalue - название ключа, по которому в   хранилище данных (DataKeeper) будет искаться значение для подстановки.
  defaultValue - значение по умолчанию, которое будет использоваться, если в хранилище данные нет ключа DPvalue.
  Пример шага: 
   `И перейти по адресу "ДатаПровайдер!(link,https://google.ru)"`
 
 4.2) В  имплементации cucumber шага, для динамической подстановки значений из дата провайдера необходимо воспользоваться методом 
`DataRandomGenerator.replaceAllGeneratingValues()` в который передать строку вида  `ДатаПровайдер!(DPvalue,defaultValue)`  

###Использование баз данных в тестах.
Перед началом работы с базой данных необходимо указать настройки БД в файле `database.properties`, либо передать в командной строке передать след. параметры:
`-Ddatasource.url="jdbc:postgresql://localhost:5432/data_base"`
`-Ddatasource.username="name"`
`-Ddatasource.password="password"`
 
### Запуск фреймворка в качестве приложения.
#### Запуск проекта 

Для запуска проекта введите команду 

    mvn spring-boot:run

В случае успешного запуска программы по адресу 

    http://localhost:8090/swagger-ui.html

Вам доступен Swagger.

#### Дополнительные Параметры

Порт для запускаемого приложения можно отредактировать   application.properties файле:

    server.port=8090
 
 либо передать при запуске 
 
    -Dserver.port=8090

#### Запуск тестовых feature файлов
Для запуска тестов, нужно отправить POST запрос про адресу

       http://localhost:8090/test 
Передав в качестве параметров: 
* Feature файл
* Json c настройками запуска. 

Пример json файла :
           
           { "site_url": "https:ya.ru",  "browser": "chrome",  "browser_config": "config/browser.config/chromedriver.config.yaml",  "hub_url": "localhost", "remote": "false", "proxy": "false",  "proxy_config": "",  "alias_input": "",  "alias_output": "" }  
            
 Полный пример запроса 
    
    
       curl -X POST "http://localhost:8099/test" -H "accept: text/plain;charset=utf-8" -H "Content-Type: multipart/form-data" -F "feature=@SampleScenarioRU.feature;type=" -F "testProperties={ "site_url": "https:ya.ru", "browser": "chrome", "browser_config": "config/browser.config/chromedriver.config.yaml", "hub_url": "localhost", "remote": "false", "proxy": "false", "proxy_config": "", "alias_input": "", "alias_output": "" }"
  
  Ответом на запрос приходит идентификатор запуска теста - *UUID*.
  
  Зная UUID запущенного теста, с помощью запросов: 
  
  * Можно узнать статус запущеннего теста.
     
         http://localhost:8090/status/{uuid} 
          
  
  * Скачать zip архив содержащий Allure отчет о прохождении теста.
  
     
         http://localhost:8090/allure/download/{uuid} 
      
 
 *  Удалить Allure отчет о прохождении теста
 
 
         http://localhost:8090/allure/delete/{uuid}
    
     

 ### Github actions (CI)
 1. В файле .github/workflows/docker-image.yml описан пайплайн запуска unit тестов и деплой docker-образа с фреймворком в docker hub.
 2. Запуск пайплайна происходит при пуше в ветку, указанную в файле docker-image.yml. Включает в себя 3 джобы:
     1.1 Запуск юнит тестов
     1.2 После успешного прохождения юнит тестов, запускается билд docker-образа с фреймворком
     1.3 После успешного билда, запускается деплой docker-образа с фреймворком в docker hub.
 3. Для запуска сервера CI необходимо запустить скрипт start-runner. После запуска скрипта поднимется GitHub runner. 
 4. В файле start-runner прописывается пароль от docker hub для пуша образа. Логин передается в открытом виде в файле docker-image.yml. Также скрипт содержит в себе необходимые параметры для запуска контейнера с раннером.
    RUNNER_NAME - имя раннера, для отображения на странице `https://github.com/<username>/<projectname>/settings/actions`
    GITHUB_ACCESS_TOKEN - токен для доступа к репозиторию github
    RUNNER_REPOSITORY_URL - адрес репозитория
    RUNNER_WORK_DIRECTORY - рабочая директория раннера
    Параметр -v для реализации Docker-in-Docker, alozhkin/github-runner-maven-jdk8 - имя образа с установленным раннером, jdk8, maven, docker.
    После создания образа происходит создание файла с паролем от docker hub.
 5. Отображение статуса раннеров находится на странице `https://github.com/<username>/<projectname>/settings/actions`.
 6. Просмотр выполнения CI на странице `https://github.com/<username>/<projectname>/actions`

